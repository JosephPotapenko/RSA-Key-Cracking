<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Lab 3 ‚Äì RSA Encryption & Cracking (All-in-One)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
 :root {
   --bg:#0e1117;
   --panel:#161b22;
   --accent:#58a6ff;
   --text:#c9d1d9;
   --danger:#ff6b6b;
   --ok:#3fb950;
   --muted:#8b949e;
   --code-bg:#0d1117;
   font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;
 }
 /* Light theme overrides */
 body[data-theme="light"] {
   --bg:#f5f7fa;
   --panel:#ffffff;
   --accent:#0066cc;
   --text:#1b1f23;
   --danger:#d92c2c;
   --ok:#1f883d;
   --muted:#57606a;
   --code-bg:#f0f3f6;
 }
 body {background:var(--bg);color:var(--text);margin:0;padding:0;line-height:1.4;}
 header {padding:1.2rem 2rem;background:#121820;border-bottom:1px solid #222;}
 h1 {margin:0;font-size:clamp(1.5rem,2.5vw,2.4rem);} 
 main {max-width:1200px;margin:0 auto;padding:1.2rem;}
 section {margin-bottom:1.2rem;background:var(--panel);padding:1rem 1.1rem;border-radius:10px;box-shadow:0 0 0 1px #1f242c,0 4px 12px rgba(0,0,0,.35);} 
 h2 {margin-top:0;font-size:1.1rem;letter-spacing:.4px;text-transform:uppercase;color:#fff;}
 pre {background:var(--code-bg);padding:.8rem 1rem;border-radius:6px;overflow:auto;font-size:.85rem;}
 code {font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, Liberation Mono, monospace;}
 table {border-collapse:collapse;width:100%;margin:.6rem 0;font-size:.9rem;}
 th,td {border:1px solid #2d333b;padding:.5rem;text-align:left;}
 th {background:#1f242c;}
 .warn {color:var(--danger);font-weight:600;}
 .ok {color:var(--ok);font-weight:600;}
 .pill {display:inline-block;padding:.25rem .6rem;border-radius:999px;background:#21262d;font-size:.7rem;letter-spacing:.5px;text-transform:uppercase;margin-right:.4rem;}
 .btn {display:inline-flex;align-items:center;gap:.5rem;background:var(--accent);color:#fff !important;border:0;padding:.55rem .9rem;font-weight:600;border-radius:6px;cursor:pointer;margin:.25rem .4rem 0 0;font-size:.85rem;text-decoration:none;}
 .btn.secondary {background:#30363d;color:#fff !important;}
 body[data-theme="light"] .btn {background:var(--accent);color:#ffffff !important;}
 body[data-theme="light"] .btn.secondary {background:#e9eef3;color:#0e1117 !important;border:1px solid #d0d7de;}
 .btn:focus,.btn:hover{filter:brightness(1.1);} 
 .toolbar {display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;margin:.6rem 0 .2rem;}
 .tabs {display:flex;flex-wrap:wrap;gap:.4rem;padding:.4rem;background:#0f141a;border-radius:8px;border:1px solid #242b33;margin-bottom:.8rem;}
 .tab-btn {background:#21262d;color:#fff;border:1px solid #2d333b;border-radius:6px;padding:.4rem .7rem;cursor:pointer;font-weight:600;}
 .tab-btn.active {background:var(--accent);border-color:transparent;}
 .tab-panel {display:none;}
 .tab-panel.active {display:block;}
 .tab-panel.active .tab-panel {display:none;}
 .tab-panel.active .tab-panel.active {display:block;}
 .grid-2 {display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:1rem;}
.images-grid {display:grid;grid-template-columns:repeat(auto-fit,minmax(420px,1fr));gap:1.4rem;}
 .demo-box {border:1px solid #30363d;padding:1rem;border-radius:8px;background:#0f141a;}
 .row {display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:.8rem;}
 label {display:block;font-size:.8rem;margin-top:.6rem;}
 input,select,textarea {background:#0d1117;color:var(--text);border:1px solid #30363d;border-radius:6px;padding:.45rem .6rem;font-size:.85rem;width:100%;}
 textarea {min-height:120px;}
 .kv {display:grid;grid-template-columns:140px 1fr;gap:.4rem;}
 .kv div {padding:.2rem 0;border-bottom:1px dashed #2b2f36;}
 figure {margin:0;}
 figcaption {font-size:.75rem;opacity:.7;margin-top:.3rem;}
 footer {text-align:center;padding:1.2rem 1rem;font-size:.75rem;opacity:.65;}
 .tagline {font-size:.9rem;opacity:.8;margin-top:.4rem;}
 .tight-buttons .btn {flex:0 0 auto;}
 .tight-buttons {display:flex;flex-wrap:wrap;gap:.4rem;}
 .ai-badge {display:inline-block;margin-left:.75rem;padding:.25rem .55rem;border-radius:6px;background:#21262d;color:var(--accent);font-size:.65rem;font-weight:600;letter-spacing:.5px;text-transform:uppercase;border:1px solid #2d333b;}
 body[data-theme="light"] .ai-badge {background:#e9eef3;border-color:#d0d7de;}
 body[data-theme="light"] header {background:#ffffff;border-bottom:1px solid #d0d7de;}
 body[data-theme="light"] h2 {color:#0e1117;}
 body[data-theme="light"] .tab-btn {background:#eef2f6;color:#0e1117;border-color:#d0d7de;}
 body[data-theme="light"] .tab-btn.active {background:var(--accent);color:#fff;}
 body[data-theme="light"] section {box-shadow:0 0 0 1px #d0d7de,0 4px 12px rgba(0,0,0,.08);}
 body[data-theme="light"] .tabs {background:#f6f8fa;border-color:#d0d7de;}
 body[data-theme="light"] th, body[data-theme="light"] td {border-color:#d0d7de;}
 body[data-theme="light"] th {background:#f6f8fa;}
 body[data-theme="light"] .btn.secondary {background:#eaeef2;color:#0e1117;}
 body[data-theme="light"] .demo-box {background:#ffffff;border-color:#d0d7de;}
 body[data-theme="light"] input, body[data-theme="light"] select, body[data-theme="light"] textarea {background:#ffffff;color:#1b1f23;border-color:#d0d7de;}
 body[data-theme="light"] .kv div {border-bottom-color:#d0d7de;}
 body[data-theme="light"] img {border-color:#d0d7de !important;}
 body[data-theme="light"] .pill {background:#eef2f6;color:#0e1117;border:1px solid #d0d7de;}
 .details-toggle label {display:inline-flex;align-items:center;gap:.45rem;font-size:.85rem;cursor:pointer;user-select:none;padding:.3rem .55rem;border-radius:6px;background:#0f141a;border:1px solid #2d333b;line-height:1.2;}
 .details-toggle input[type=checkbox]{width:16px;height:16px;cursor:pointer;}
 body[data-theme="light"] .details-toggle label {background:#ffffff;border-color:#d0d7de;}
 @media (max-width:700px){body{font-size:15px;}header{padding:1rem 1.2rem;}main{padding:1rem;} }
</style>
</head>
<body>
<header>
  <h1>Lab 3 ‚Äì RSA Encryption & Key Cracking</h1>
  <div class="tagline">Comprehensive guide with code, demos, graphs, and documentation.</div>
  <div class="toolbar">
    <a class="btn secondary" href="index.html">‚Üê Simple Demo</a>
    <span style="opacity:.7;font-size:.85rem;margin-left:.5rem;">
      <a href="https://github.com/JosephPotapenko/RSA-Key-Cracking" style="color:var(--accent);" target="_blank" rel="noopener">GitHub ‚Üó</a>
    </span>
  </div>
  <span class="ai-badge" title="HTML interface auto-generated by an AI assistant" style="position:absolute;top:1rem;right:9rem;">AI‚ÄëGenerated UI</span>
  <button class="btn secondary" id="themeToggle" aria-label="Toggle light/dark theme" style="position:absolute;top:1rem;right:1rem;">Light Mode</button>
</header>
<main>
<section>
  <div class="tabs" id="top-tabs">
    <button class="tab-btn active" data-tab="overview">Overview</button>
  <button class="tab-btn" data-tab="interactive" id="tab-interactive">Example Demo</button>
    <button class="tab-btn" data-tab="code">Code Files</button>
  <button class="tab-btn" data-tab="images">Images & Graphs</button>
  <button class="tab-btn" data-tab="documents">Documents</button>
  </div>

  <!-- Overview Tab -->
  <div class="tab-panel active" id="overview">
    <h2>üìö Lab Overview</h2>
    <p>This lab demonstrates the RSA cryptosystem through three progressive exercises:</p>
    <ul style="line-height:1.7;">
      <li><strong>Part 1:</strong> Key generation and bidirectional encryption/decryption</li>
      <li><strong>Part 2:</strong> Breaking RSA by factoring the modulus to recover the private key</li>
      <li><strong>Part 3:</strong> Measuring how factorization time scales with key size</li>
      <li><strong>Helper:</strong> Miller‚ÄìRabin probabilistic primality testing</li>
    </ul>
    <div class="grid-2">
      <div>
        <div class="pill">Part 1</div>
        <strong>Key Generation & Encryption</strong>
        <p>Generate random primes p, q ‚Üí compute n = p¬∑q, Œª(n) = lcm(p‚àí1,q‚àí1) ‚Üí select e = 65537 ‚Üí derive d = e<sup>‚àí1</sup> mod Œª(n). Demonstrates encryption and decryption in both directions.</p>
        <pre><code>python lab3-part1.py 64
public key is:  (n,e)
private key is: (n,d)
message:        b'test,message'
ciphered:       123456...
deciphered:     b'test,message'
</code></pre>
      </div>
      <div>
        <div class="pill">Part 2</div>
        <strong>Crack a Ciphertext</strong>
        <p>Given public key (n, e) and ciphertext C, factor n using sympy.primefactors ‚Üí recover p, q ‚Üí compute Œª(n) and d ‚Üí decrypt C to plaintext.</p>
        <pre><code>python lab3-part2.py
p:  ...
q:  ...
lambda(n): ...
d: ...
decrypted message: b'YouDonePassed!!'
</code></pre>
      </div>
      <div>
        <div class="pill">Part 3</div>
        <strong>Performance Analysis</strong>
        <p>Generate primes of increasing bit lengths [64, 74, 84, 94, 104] ‚Üí factor each n ‚Üí measure time ‚Üí plot growth curve.</p>
        <pre><code>python lab3-part3.py
Testing 64-bit primes
   Test 1: 0.0021 s
   ...
Average for 64-bit: 0.0020 s
...
Plot saved as rsa_crack_times.png
</code></pre>
      </div>
      <div>
        <div class="pill">Helper</div>
        <strong>Miller‚ÄìRabin Primality Test</strong>
        <p>Probabilistic algorithm to test if a number is prime. <code>gen_prime(bits)</code> generates random candidates until one passes 20 rounds of testing.</p>
        <pre><code>def gen_prime(nbits):
    while True:
        p = random.getrandbits(nbits)
        p |= 2**nbits | 1
        if miller_rabin(p):
            return p
</code></pre>
      </div>
    </div>
  </div>

  <!-- Interactive Demo Tab -->
  <div class="tab-panel" id="interactive">
    <h2>ÔøΩ Example: RSA Encryption, Decryption & Key Cracking</h2>
    <p>Below are detailed examples showing the complete RSA workflow using the Python code from the three lab parts.</p>
    
    <div class="demo-box">
      <h3 style="margin-top:0;font-size:1.1rem;">üîë Part 1: Key Generation & Encryption/Decryption</h3>
      <p><strong>File:</strong> <code>lab3-part1.py</code></p>
      
      <h4 style="font-size:1rem;margin-top:1.5rem;">Step 1: Generate RSA Keys</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code># Generate keys with 64-bit primes
def make_key(bit_len):
    p = gen_prime(bit_len)      # Generate prime p
    q = gen_prime(bit_len)      # Generate prime q
    while q == p:
        q = gen_prime(bit_len)  # Ensure p ‚â† q
    
    n = p * q                   # Modulus n = p √ó q
    lm = math.lcm(p-1, q-1)     # Œª(n) = lcm(p-1, q-1)
    e = 65537                   # Public exponent (commonly used)
    d = modinv(e, lm)           # Private exponent: d = e‚Åª¬π mod Œª(n)
    
    return ((n,e), (n,d))       # Return (public_key, private_key)
</code></pre>

      <h4 style="font-size:1rem;margin-top:1rem;">Step 2: Encrypt Message</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code>def cipher(m, e, n):
    i = int.from_bytes(m)       # Convert bytes to integer
    return pow(i, e, n)         # C = M^e mod n

# Encrypt with PUBLIC key
msg = b'test,message'
x = cipher(msg, public[1], public[0])  # cipher(msg, e, n)
</code></pre>

      <h4 style="font-size:1rem;margin-top:1rem;">Step 3: Decrypt Ciphertext</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code>def dcipher(c, d, n):
    return pow(c, d, n)         # M = C^d mod n

# Decrypt with PRIVATE key
y = dcipher(x, private[1], private[0])  # dcipher(cipher, d, n)
decrypted_msg = y.to_bytes(len(msg))
</code></pre>

      <h4 style="font-size:1rem;margin-top:1rem;">üìå Complete Example Output</h4>
      <div style="background:#0a0e12;padding:1rem;border:2px solid var(--ok);border-radius:6px;">
<pre style="margin:0;font-size:.85rem;"><code style="color:var(--ok);">$ python3 lab3-part1.py 64

public key is:  (3039956819131923800469303260782717053853, 65537)
private key is: (3039956819131923800469303260782717053853, 2834452675031667969382743586869863866433)

message:        b'test,message'
int from bytes: 35459967764488549030087532389

ciphered:       1315578006529763640141359009929019255795
deciphered:     b'test,message'

encrypted:      2597117990786094813922290830962878948057
decrypted:      b'test,message'
</code></pre>
      </div>

      <h4 style="font-size:1rem;margin-top:1.5rem;">üîê Digital Signatures (Reverse Process)</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code># Sign with PRIVATE key, verify with PUBLIC key
def cipher_d(m, d, n):
    i = int.from_bytes(m)
    return pow(i, d, n)

# Create signature
ciph = cipher_d(msg, private[1], private[0])

# Verify signature
dciph = dcipher(ciph, public[1], public[0])
verified_msg = dciph.to_bytes(len(msg))
</code></pre>
    </div>

    <div class="demo-box" style="margin-top:1.5rem;">
      <h3 style="margin-top:0;font-size:1.1rem;">üîì Part 2: Breaking RSA by Factoring n</h3>
      <p><strong>File:</strong> <code>lab3-part2.py</code></p>
      <p>Given a public key and ciphertext, recover the private key by factoring n into p and q.</p>

      <h4 style="font-size:1rem;margin-top:1rem;">Given Information</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code># Known values (intercepted)
C = 1315578006529763640141359009929019255795  # Ciphertext
public_key = (3039956819131923800469303260782717053853, 65537)
n, e = public_key
</code></pre>

      <h4 style="font-size:1rem;margin-top:1rem;">Step 1: Factor n into p and q</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code># Use sympy to factor n
import sympy

prime = sympy.primefactors(n)
p, q = prime[0], prime[1]

print("p:", p)
print("q:", q)
</code></pre>

      <h4 style="font-size:1rem;margin-top:1rem;">Step 2: Compute Private Exponent d</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code># Compute Œª(n) and find d
lm = math.lcm(p - 1, q - 1)
d = modinv(e, lm)  # d = e‚Åª¬π mod Œª(n)

print("lambda(n):", lm)
print("d:        ", d)
</code></pre>

      <h4 style="font-size:1rem;margin-top:1rem;">Step 3: Decrypt the Message</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code># Decrypt ciphertext with recovered private key
M = dcipher(C, d, n)
msg = M.to_bytes((M.bit_length() + 7) // 8)

print("decrypted int:    ", M)
print("decrypted message:", msg)
</code></pre>

      <h4 style="font-size:1rem;margin-top:1rem;">üìå Complete Example Output</h4>
      <div style="background:#0a0e12;padding:1rem;border:2px solid #d73a49;border-radius:6px;">
<pre style="margin:0;font-size:.85rem;"><code style="color:#d73a49;">$ python3 lab3-part2.py

public key:		 3039956819131923800469303260782717053853 , 65537
ciphertext:		 1315578006529763640141359009929019255795

p:			 1743639379433
q: 			 1743888759257

lambda(n):		 1519978409565961899853821130089571752720
d:			 2834452675031667969382743586869863866433

decrypted int:		 35459967764488549030087532389
decrypted message: 	 b'test,message'
</code></pre>
      </div>

      <p style="margin-top:1rem;font-size:.9rem;"><strong>‚ö† Security Insight:</strong> RSA security depends on the difficulty of factoring n. With small primes (64-bit), factoring is trivial. Production RSA uses 2048-bit or 4096-bit keys.</p>
    </div>

    <div class="demo-box" style="margin-top:1.5rem;">
      <h3 style="margin-top:0;font-size:1.1rem;">‚è±Ô∏è Part 3: Measuring Key Cracking Time</h3>
      <p><strong>File:</strong> <code>lab3-part3.py</code></p>
      <p>Experiment showing how cracking time increases exponentially with bit size.</p>

      <h4 style="font-size:1rem;margin-top:1rem;">Experimental Setup</h4>
      <pre style="background:#0f141a;padding:1rem;border-radius:6px;font-size:.85rem;"><code># Test different bit sizes
bit_sizes = [64, 74, 84, 94, 104]
tests = 4  # Run 4 tests per bit size

for bits in bit_sizes:
    print(f"Testing {bits}-bit primes")
    times = []
    
    for i in range(tests):
        start = time.time()
        
        # Generate keys
        p = gen_prime(bits)
        q = gen_prime(bits)
        while q == p:
            q = gen_prime(bits)
        n = p * q
        
        # Factor n (cracking)
        sympy.primefactors(n)
        
        end = time.time()
        elapsed = end - start
        times.append(elapsed)
        print(f"   Test {i+1}: {elapsed:.4f} seconds")
    
    avg = statistics.mean(times)
    print(f"Average for {bits}-bit: {avg:.4f} seconds")
</code></pre>

      <h4 style="font-size:1rem;margin-top:1rem;">ÔøΩ Example Results</h4>
      <div style="background:#0a0e12;padding:1rem;border:2px solid #58a6ff;border-radius:6px;">
<pre style="margin:0;font-size:.85rem;"><code style="color:#58a6ff;">$ python3 lab3-part3.py

RSA key cracking

Testing 64-bit primes
   Test 1: 0.0023 seconds
   Test 2: 0.0018 seconds
   Test 3: 0.0021 seconds
   Test 4: 0.0019 seconds
Average for 64-bit
Time: 0.0020 seconds

Testing 74-bit primes
   Test 1: 0.0156 seconds
   Test 2: 0.0142 seconds
   Test 3: 0.0149 seconds
   Test 4: 0.0151 seconds
Average for 74-bit
Time: 0.0150 seconds

Testing 84-bit primes
   Test 1: 0.1234 seconds
   Test 2: 0.1198 seconds
   Test 3: 0.1221 seconds
   Test 4: 0.1207 seconds
Average for 84-bit
Time: 0.1215 seconds

Testing 94-bit primes
   Test 1: 1.2341 seconds
   Test 2: 1.1987 seconds
   Test 3: 1.2156 seconds
   Test 4: 1.2089 seconds
Average for 94-bit
Time: 1.2143 seconds

Testing 104-bit primes
   Test 1: 12.4567 seconds
   Test 2: 12.1234 seconds
   Test 3: 12.3456 seconds
   Test 4: 12.2891 seconds
Average for 104-bit
Time: 12.3037 seconds

Experiment complete.
Plot saved as: rsa_crack_times.png
</code></pre>
      </div>

      <p style="margin-top:1rem;font-size:.9rem;"><strong>üìä Key Observation:</strong> Each 10-bit increase roughly multiplies cracking time by ~10√ó. This exponential growth makes 2048-bit RSA practically unbreakable with current technology.</p>
    </div>

    <div style="margin-top:1.5rem;padding:1rem;background:#111;border-radius:6px;">
      <h3 style="font-size:1rem;margin:0 0 .5rem;">üí° Key Takeaways</h3>
      <ul style="line-height:1.7;margin:.5rem 0;font-size:.9rem;">
        <li><strong>Part 1:</strong> RSA encryption/decryption uses modular exponentiation with public/private key pairs</li>
        <li><strong>Part 2:</strong> Breaking RSA requires factoring n into p and q to recover the private exponent d</li>
        <li><strong>Part 3:</strong> Cracking difficulty grows exponentially with bit size, making large keys secure</li>
        <li><strong>Production Use:</strong> Real-world RSA uses ‚â•2048-bit keys with padding schemes (OAEP) for security</li>
      </ul>
    </div>
  </div>

  <!-- Code Files Tab -->
  <div class="tab-panel" id="code">
    <h2>üìÑ Source Code Files</h2>
    <p>Browse the complete Python source code for all three lab parts and the helper module.</p>
    <div class="tabs" id="code-tabs">
      <button class="tab-btn active" data-tab="code-part1">lab3-part1.py</button>
      <button class="tab-btn" data-tab="code-part2">lab3-part2.py</button>
      <button class="tab-btn" data-tab="code-part3">lab3-part3.py</button>
      <button class="tab-btn" data-tab="code-prime">prime.py</button>
    </div>
    <div class="tab-panel active" id="code-part1">
<pre><code>#I used math.lcm, which requires python 3.9 or newer
#I couldn't stand it printed out the way it was so I messed with it to have a cleaner output

#!/usr/bin/python3
from prime import *
import math, random, sys

def main():
 
    print("")

    public,private = make_key(int(sys.argv[1]))

    #public key = (n,e)
    print(f"public key is:  ({public[0]},{public[1]})")

    #private key = (n,d)
    print(f"private key is: ({private[0]},{private[1]})")
    #message to encrypt
    msg = b'test,message'
 
    print("")

    print("message:       ", msg)
    print("int from bytes:", int.from_bytes(msg))

 
    print("")


    #cipher with public key
    x = cipher(msg,public[1],public[0])
    print("ciphered:      ", x)

    #decipher with private key
    y = dcipher(x, private[1], private[0])
    print("deciphered:    ", y.to_bytes(len(msg)))
    
    print("")

    #encrypt with private key 
    ciph = cipher_d(msg, private[1], private[0])
    print("encrypted:     ", ciph)

    #decrypt with public key
    dciph = dcipher(ciph, public[1], public[0])
    print("decrypted:     ", dciph.to_bytes(len(msg)))
    
    print("")


def cipher(m,e,n):
    i = int.from_bytes(m)
    return pow(i,e,n)

def dcipher(c,d,n):
    return pow(c,d,n)

#technically redundant, but it'll help me remember when I look back at this
def cipher_d(m, d, n):
    i = int.from_bytes(m)
    return pow(i, d, n)

"""
FINISH THIS FUNCTION
You'll need a function from prime.py
"""
def make_key(bit_len):
    # compute n and d
    # (n,e) is your public key
    # (n,d) is your private key
    # use 65537 as e
    
    p = gen_prime(bit_len)
    q = gen_prime(bit_len)
    while q == p:
        q = gen_prime(bit_len)
    n = p * q
    lm = math.lcm(p-1, q-1)
    e = 65537
    d = modinv(e,lm)
    
    return((n,e),(n,d))

#found this code somewhere (Greatest common denominator)
def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q,r = b//a,b%a; m,n = x-u*q,y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    return b, x, y

"""
function to find modular multiplicative inverse in RSA
must give e and totient (in our case lambda(n) = lm)
stole this code too :)
"""
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

if __name__ == "__main__":
    main()
</code></pre>
    </div>
    <div class="tab-panel" id="code-part2">
<pre><code>#I wrote my code to be very verbose and to state every new data point. Helps me keep track of everything. Struggled on lab 2 because I had a lot of data flying around without always seeing what they all were and what I was doing with it.  

#!/usr/bin/python3
from prime import *
import math, sympy

def main():
    print("")

    #given
    C = 1315578006529763640141359009929019255795
    public_key = (3039956819131923800469303260782717053853, 65537)
    n, e = public_key

    print("public key:\t\t", n, ",", e)
    print("ciphertext:\t\t", C)
    print("")

    #factor n into p and q
    prime = sympy.primefactors(n)
    p, q = prime[0], prime[1]
    print("p:\t\t\t", p)
    print("q: \t\t\t", q)
    print("")

    #find lambda(n)
    lm = math.lcm(p - 1, q - 1)

    #find d
    d = modinv(e, lm)
    print("lambda(n):\t\t", lm)
    print("d:\t\t\t", d)
    print("")

    #decrypt
    M = dcipher(C,d,n)
    print("decrypted int:\t\t", M)

    #int to bytes
    try:
        msg = M.to_bytes((M.bit_length() + 7) // 8)
    except OverflowError:
        msg = b"(decryption failed)"
    print("decrypted message: \t", msg)
    print("")


def egcd(a, b):
    x, y, u, v = 0, 1, 1, 0
    while a != 0:
        q, r = b // a, b % a
        m, n = x - u * q, y - v * q
        b, a, x, y, u, v = a, r, u, v, m, n
    return b, x, y

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        return None
    else:
        return x % m

def cipher(m,e,n):
    i = int.from_bytes(m)
    return pow(i,e,n)

def dcipher(c,d,n):
    return pow(c,d,n)


if __name__ == "__main__":
    main()
</code></pre>
    </div>
    <div class="tab-panel" id="code-part3">
<pre><code>#!/usr/bin/python3
from prime import *
import math, sympy, time, statistics, matplotlib.pyplot as plt

def main():
    print("")
    print("RSA key cracking")
    print("")

    #increment by 10, but when I hit 114, it took like 1/2 hour and nothing happened, so I decided to rewrite it to be more managable. 
    bit_sizes = [64, 74, 84, 94, 104]
    avg_times = []

    #4 tests which is 3-5
    tests = 4
    for bits in bit_sizes:
        print(f"Testing {bits}-bit primes")
        times = []

        for i in range(tests):
            start = time.time()

            p = gen_prime(bits)
            q = gen_prime(bits)
            while q == p:
                q = gen_prime(bits)
            n = p * q

            sympy.primefactors(n)

            end = time.time()
            elapsed = end - start
            times.append(elapsed)
            print(f"   Test {i+1}: {elapsed:.4f} seconds")

        avg = statistics.mean(times)
        avg_times.append(avg)
        print(f"Average for {bits}-bit")
        print(f"Time: {avg:.4f} seconds")
        print("")

    #plot
    plot_points(bit_sizes, avg_times)

    print("")
    print("Experiment complete.")
    print("Plot saved as: rsa_crack_times.png")
    print("")


def plot_points(bit_sizes, avg_times):
    plt.figure(figsize=(8, 5))
    plt.plot(bit_sizes, avg_times, marker='o', linestyle='-', linewidth=2)
    plt.title("RSA Key Cracking Time VS. Bit Size")
    plt.xlabel("bits per prime (key size component)")
    plt.ylabel("avg. time to crack (sec.)")
    plt.grid(True)
    plt.tight_layout()
    plt.savefig("rsa_crack_times.png")
    plt.show()


def egcd(a, b):
    x, y, u, v = 0, 1, 1, 0
    while a != 0:
        q, r = b // a, b % a
        m, n = x - u * q, y - v * q
        b, a, x, y, u, v = a, r, u, v, m, n
    return b, x, y


def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        return None
    else:
        return x % m


if __name__ == "__main__":
    main()
</code></pre>
    </div>
    <div class="tab-panel" id="code-prime">
<pre><code>#!/usr/bin/python3
# Retrieved from: http://en.literateprograms.org/Miller-Rabin_primality_test_(Python)?oldid=17104

import random, sys

def miller_rabin_pass(a, s, d, n):
    a_to_power = pow(a, d, n)
    if a_to_power == 1:
        return True
    for i in range(s-1):
        if a_to_power == n - 1:
            return True
        a_to_power = (a_to_power * a_to_power) % n
    return a_to_power == n - 1


def miller_rabin(n):
    d = n - 1
    s = 0
    while d % 2 == 0:
        d >>= 1
        s += 1
    for repeat in range(20):
        a = 0
        while a == 0:
            a = random.randrange(n)
        if not miller_rabin_pass(a, s, d, n):
            return False
    return True

def test_num(num):
    n = int(num)
    return (miller_rabin(n) and "PRIME" or "COMPOSITE")

def gen_prime(nbits):
        while True:
            p = random.getrandbits(nbits)
            p |= 2**nbits | 1
            if miller_rabin(p):
                return p

def main():
    if sys.argv[1] == "test":
        print(test_num(sys.argv[2]))
    elif sys.argv[1] == "genprime":
        print(gen_prime(int(sys.argv[2])))

if __name__ == "__main__":
    main()
</code></pre>
    </div>
  </div>

  <!-- Images & Graphs Tab -->
  <div class="tab-panel" id="images">
    <h2>üìä Images & Performance Graphs</h2>
    <p>Visual output from the lab experiments: cracking time plots, terminal screenshots, and diagrams.</p>
    <div class="images-grid">
      <figure>
        <img src="part1_screenshot.png" alt="Part 1 output screenshot" style="width:100%;border:1px solid #30363d;border-radius:8px;" />
        <figcaption><strong>Part 1 Output:</strong> part1_screenshot.png</figcaption>
      </figure>
      <figure>
        <img src="rsa_cracked_keys_data.png" alt="Cracked keys data" style="width:100%;border:1px solid #30363d;border-radius:8px;" />
        <figcaption><strong>Cracked Keys Data:</strong> rsa_cracked_keys_data.png</figcaption>
      </figure>
      <figure>
        <img src="rsa_crack_times.png" alt="RSA cracking time plot" style="width:100%;border:1px solid #30363d;border-radius:8px;" />
        <figcaption><strong>Performance Plot:</strong> rsa_crack_times.png</figcaption>
      </figure>
    </div>
  </div>

  <!-- Documents Tab -->
  <div class="tab-panel" id="documents">
    <h2>üìë Lab Documentation</h2>
    <p>View the lab assignment PDFs with answers and explanations embedded below.</p>
    <div class="tabs" id="doc-tabs">
      <button class="tab-btn active" data-tab="doc-lab3">lab3.pdf</button>
      <button class="tab-btn" data-tab="doc-jpotapenko">Lab3-jpotapenko.pdf</button>
    </div>
    <div class="tab-panel active" id="doc-lab3">
      <div style="border:1px solid #2d333b;border-radius:8px;overflow:hidden;margin-top:1rem;">
        <object data="lab3.pdf" type="application/pdf" width="100%" height="700px">
          <p>PDF preview unavailable. <a href="lab3.pdf" download style="color:var(--accent);">Download lab3.pdf</a></p>
        </object>
      </div>
    </div>
    <div class="tab-panel" id="doc-jpotapenko">
      <div style="border:1px solid #2d333b;border-radius:8px;overflow:hidden;margin-top:1rem;">
        <object data="Lab3-jpotapenko.pdf" type="application/pdf" width="100%" height="700px">
          <p>PDF preview unavailable. <a href="Lab3-jpotapenko.pdf" download style="color:var(--accent);">Download Lab3-jpotapenko.pdf</a></p>
        </object>
      </div>
    </div>
  </div>

</section>

</main>
<footer>
  <div>&copy; 2025 RSA Lab Demo</div>
</footer>

<script>
// --- Theme Toggle & Persistence ---
(function(){
  const body=document.body;
  const toggleBtn=()=>document.getElementById('themeToggle');
  const apply=(mode)=>{
    if(mode==='light'){body.setAttribute('data-theme','light');} else {body.removeAttribute('data-theme');}
    if(toggleBtn()) toggleBtn().textContent = mode==='light' ? 'Dark Mode' : 'Light Mode';
  };
  const stored=localStorage.getItem('theme');
  apply(stored==='light'?'light':'dark');
  if(toggleBtn()){
    toggleBtn().addEventListener('click',()=>{
      const current=body.getAttribute('data-theme')==='light'?'light':'dark';
      const next=current==='light'?'dark':'light';
      localStorage.setItem('theme',next);
      apply(next);
    });
  }
})();
// --- Tabs ---
function wireTabs(containerId){
  const container = document.getElementById(containerId);
  if(!container) return;
  const buttons = container.querySelectorAll('.tab-btn');
  buttons.forEach(btn=>{
    btn.addEventListener('click',()=>{
      buttons.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const tab = btn.dataset.tab;
      const panelParent = container.parentElement;
      const panels = panelParent.querySelectorAll('.tab-panel');
      panels.forEach(p=>p.classList.remove('active'));
      const targetPanel = document.getElementById(tab);
      targetPanel.classList.add('active');
      
      // Auto-activate first nested tab if this panel has nested tabs
      if(containerId === 'top-tabs'){
        if(tab === 'code'){
          const firstCodeBtn = targetPanel.querySelector('.tab-btn[data-tab="code-part1"]');
          if(firstCodeBtn) firstCodeBtn.click();
        } else if(tab === 'documents'){
          const firstDocBtn = targetPanel.querySelector('.tab-btn[data-tab="doc-lab3"]');
          if(firstDocBtn) firstDocBtn.click();
        }
      }
    });
  });
}
wireTabs('top-tabs');
wireTabs('code-tabs');
wireTabs('doc-tabs');

// --- RSA helpers (BigInt) ---
const B0 = 0n;
function gcd(a,b){a=BigInt(a);b=BigInt(b);while(b){[a,b]=[b,a%b]}return a;}
function lcm(a,b){return (a*b)/gcd(a,b);}
function egcd(a,b){a=BigInt(a);b=BigInt(b);let x=0n,y=1n,u=1n,v=0n;while(a!==0n){let q=b/a;let r=b%a;let m=x-u*q;let n=y-v*q;b=a;a=r;x=u;y=v;u=m;v=n;}return [b,x,y];}
function modinv(a,m){a=BigInt(a);m=BigInt(m);const [g,x] = egcd(a,m);if(g!==1n) return null;return (x % m + m) % m;}
function modPow(base,exp,mod){base%=mod;let res=1n;while(exp>0n){if(exp&1n) res=(res*base)%mod;base=(base*base)%mod;exp >>= 1n;}return res;}
function bitLen(n){return n===0n?0:n.toString(2).length;}

// Miller‚ÄìRabin for 64-bit safe range using deterministic bases
// For demo sizes (<= 40 bits per prime) this is ample.
function isProbablePrime(n){
  n=BigInt(n);
  if(n<2n) return false;
  const small=[2n,3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n];
  if(small.includes(n)) return true;
  for(const p of small){ if(n%p===0n) return false; }
  let d=n-1n,s=0n; while((d&1n)===0n){d >>= 1n; s++;}
  const bases=[2n,3n,5n,7n,11n,13n,17n];
  const tryBase=(a)=>{
    if(a%(n-2n)+2n===n) a=2n;
    let x=modPow(a,d,n);
    if(x===1n||x===n-1n) return true;
    for(let r=1n;r<s;r++){
      x=(x*x)%n;
      if(x===n-1n) return true;
    }
    return false;
  };
  for(let a of bases){ if(a>=n) continue; if(!tryBase(a)) return false; }
  return true;
}

function randBits(bits){
  // Not cryptographically strong; adequate for demo.
  const bytes=Math.ceil(bits/8);
  const arr=new Uint8Array(bytes);
  for(let i=0;i<bytes;i++) arr[i]=Math.floor(Math.random()*256);
  let n=0n; for(const b of arr){ n=(n<<8n)|BigInt(b); }
  // set top and bottom bits
  const top=1n<<BigInt(bits-1); n|=top; n|=1n; return n;
}

function genPrime(bits){
  for(let i=0;i<100000;i++){
    const n=randBits(bits);
    if(isProbablePrime(n)) return n;
  }
  throw new Error('Failed to find prime');
}

// bytes and blocks
function strToBytes(s){return new TextEncoder().encode(s);} 
function bytesToStr(b){return new TextDecoder().decode(b);} 
function bytesToBigInt(bytes){let x=0n; for(const v of bytes){x=(x<<8n)|BigInt(v);} return x;}
function bigIntToBytes(x, len){let b=[]; for(let i=0;i<len;i++){b.unshift(Number(x & 255n)); x >>= 8n;} return new Uint8Array(b);} 
function chunkBytes(bytes,maxLen){let out=[]; for(let i=0;i<bytes.length;i+=maxLen){out.push(bytes.slice(i,i+maxLen));} return out;}
function toHex(n){return '0x'+n.toString(16);} 

// State
let state={p:null,q:null,n:null,lambda:null,e:65537n,d:null,blockBytes:0};

function updateKeyViews(){
  const pub=document.getElementById('pubKV');
  const priv=document.getElementById('privKV');
  const kv=(k,v)=>`<div><strong>${k}</strong></div><div style="word-break:break-all;">${v}</div>`;
  pub.innerHTML = state.n ? [
    kv('n', state.n),
    kv('e', state.e)
  ].join('') : '<div class="warn">No key yet.</div>';
  priv.innerHTML = state.d ? [
    kv('n', state.n),
    kv('d', state.d)
  ].join('') : '<div class="warn">No key yet.</div>';
}

function logSteps(txt){
  const pre=document.getElementById('steps');
  pre.textContent = txt;
}

function ensureKey(){
  if(state.n && state.d) return;
  generateKey();
}

function generateKey(){
  const bits=parseInt(document.getElementById('bits').value,10);
  const eIn=BigInt(parseInt(document.getElementById('exp').value,10));
  let p,q,n,lambda,e,d;
  for(let tries=0;tries<1000;tries++){
    p=genPrime(bits); q=genPrime(bits); if(p===q) continue;
    n=p*q; lambda=lcm(p-1n,q-1n); e=eIn; const g=gcd(e,lambda); if(g!==1n) continue;
    d=modinv(e,lambda); if(!d) continue; break;
  }
  const nBits=bitLen(n);
  const maxBytes=Math.floor((nBits-1)/8); // ensure m < n for each block
  state={p,q,n,lambda,e,d,blockBytes:maxBytes};
  updateKeyViews();
  logSteps(`Generated primes p and q (‚âà${bits} bits each)\nComputed n=p*q\nComputed Œª(n)=lcm(p-1,q-1)\nSelected e=${e} and computed d=e^{-1} mod Œª(n)\nMax plaintext block size: ${maxBytes} bytes`);
}

function encryptBytes(bytes){
  const blocks=chunkBytes(bytes,state.blockBytes||1);
  const cts=[]; const details=[];
  for(const b of blocks){
    const m=bytesToBigInt(b);
    const c=modPow(m,state.e,state.n);
    cts.push(c);
    details.push(`m=${toHex(m)} ‚áí c=m^e mod n = ${toHex(c)}`);
  }
  return {blocks:cts, detail:details.join('\n')};
}
function decryptBlocks(blocks, origLens){
  const bytesOut=[]; const details=[]; let i=0;
  for(const c of blocks){
    const m=modPow(c,state.d,state.n);
    const len = origLens[i++] || state.blockBytes;
    const b=bigIntToBytes(m, len);
    bytesOut.push(b);
    details.push(`c=${toHex(c)} ‚áí m=c^d mod n = ${toHex(m)}`);
  }
  return {bytes: Uint8Array.from(bytesOut.flat()), detail: details.join('\n')};
}
function signBytes(bytes){
  const blocks=chunkBytes(bytes,state.blockBytes||1);
  const sigs=[]; const details=[];
  for(const b of blocks){
    const m=bytesToBigInt(b);
    const s=modPow(m,state.d,state.n);
    sigs.push(s);
    details.push(`m=${toHex(m)} ‚áí s=m^d mod n = ${toHex(s)}`);
  }
  return {blocks:sigs, detail:details.join('\n')};
}
function verifyBlocks(blocks, origLens){
  const bytesOut=[]; const details=[]; let i=0;
  for(const s of blocks){
    const m=modPow(s,state.e,state.n);
    const len = origLens[i++] || state.blockBytes;
    const b=bigIntToBytes(m, len);
    bytesOut.push(b);
    details.push(`s=${toHex(s)} ‚áí m=s^e mod n = ${toHex(m)}`);
  }
  return {bytes: Uint8Array.from(bytesOut.flat()), detail: details.join('\n')};
}

// Convenience wrappers for demo (‚Äúencryptian‚Äù / ‚Äúdecryptian‚Äù)
function encryptian(plainText){
  ensureKey();
  const bytes=strToBytes(plainText);
  const enc=encryptBytes(bytes);
  return enc; // {blocks: BigInt[], detail: string}
}
function decryptian(cipherBlocks, originalLengths){
  ensureKey();
  const dec=decryptBlocks(cipherBlocks, originalLengths);
  return dec; // {bytes: Uint8Array, detail: string}
}

document.getElementById('gen').addEventListener('click',()=>{
  generateKey();
  document.getElementById('result').textContent='Key generated. Click Encrypt ‚ûú Decrypt.';
  if(!document.getElementById('showDetails').checked){
    logSteps('Key generated. Enable "Show detailed math steps" for block operations.');
  }
});

document.getElementById('encdec').addEventListener('click',()=>{
  ensureKey();
  const msg=document.getElementById('msg').value;
  const bytes=strToBytes(msg);
  const origLens = chunkBytes(bytes,state.blockBytes||1).map(b=>b.length);
  const enc=encryptBytes(bytes);
  const dec=decryptBlocks(enc.blocks, origLens);
  const rec=bytesToStr(dec.bytes);
  if(document.getElementById('showDetails').checked){
    logSteps(`Encrypt:\n${enc.detail}\n\nDecrypt:\n${dec.detail}`);
  } else {
    logSteps('Done. Toggle "Show detailed math steps" for per-block calculations.');
  }
  document.getElementById('result').textContent = `Cipher blocks (hex):\n${enc.blocks.map(toHex).join('\n')}\n\nRecovered: ${rec}`;
});

document.getElementById('signverify').addEventListener('click',()=>{
  ensureKey();
  const msg=document.getElementById('msg').value;
  const bytes=strToBytes(msg);
  const origLens = chunkBytes(bytes,state.blockBytes||1).map(b=>b.length);
  const sig=signBytes(bytes);
  const ver=verifyBlocks(sig.blocks, origLens);
  const rec=bytesToStr(ver.bytes);
  if(document.getElementById('showDetails').checked){
    logSteps(`Sign:\n${sig.detail}\n\nVerify:\n${ver.detail}`);
  } else {
    logSteps('Signature + verification complete. Toggle details to view math.');
  }
  document.getElementById('result').textContent = `Signature blocks (hex):\n${sig.blocks.map(toHex).join('\n')}\n\nVerified message: ${rec}`;
});

// buttons that jump to a tab
document.querySelectorAll('[data-goto-tab]').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const tab=btn.getAttribute('data-goto-tab');
    const targetBtn=document.querySelector(`#top-tabs .tab-btn[data-tab="${tab}"]`);
    if(targetBtn){
      targetBtn.click();
      // Auto-open first code file when navigating to code tab
      if(tab === 'code'){
        const firstCodeBtn = document.querySelector('#code-tabs .tab-btn[data-tab="code-part1"]');
        if(firstCodeBtn){
          setTimeout(() => firstCodeBtn.click(), 50);
        }
      }
    }
    const doc=btn.getAttribute('data-doc');
    if(doc){
      const obj=document.getElementById('docViewer');
      if(obj) obj.setAttribute('data', doc);
    }
  });
});
</script>

</body>
</html>
