<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Lab 3 ‚Äì RSA Encryption & Cracking Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
 :root {
   --bg:#0e1117;
   --panel:#161b22;
   --accent:#58a6ff;
   --text:#c9d1d9;
   --danger:#ff6b6b;
   --ok:#3fb950;
   --code-bg:#0d1117;
   font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;
 }
 body[data-theme="light"] {
   --bg:#f5f7fa;
   --panel:#ffffff;
   --accent:#0066cc;
   --text:#1b1f23;
   --danger:#d92c2c;
   --ok:#1f883d;
   --code-bg:#f0f3f6;
 }
 body {background:var(--bg);color:var(--text);margin:0;padding:0;line-height:1.4;}
 header {padding:1.2rem 2rem;background:#121820;border-bottom:1px solid #222;}
 h1 {margin:0;font-size:clamp(1.5rem,2.5vw,2.4rem);}
 a {color:var(--accent);text-decoration:none;}a:hover{text-decoration:underline;}
 main {max-width:1000px;margin:0 auto;padding:2rem;}
 section {margin-bottom:2.5rem;background:var(--panel);padding:1.4rem 1.6rem;border-radius:10px;box-shadow:0 0 0 1px #1f242c,0 4px 12px rgba(0,0,0,.35);}
 h2 {margin-top:0;font-size:1.3rem;letter-spacing:.5px;text-transform:uppercase;color:#fff;}
 pre {background:var(--code-bg);padding:.8rem 1rem;border-radius:6px;overflow:auto;font-size:.85rem;}
 code {font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, Liberation Mono, monospace;}
 table {border-collapse:collapse;width:100%;margin:.6rem 0;font-size:.9rem;}
 th,td {border:1px solid #2d333b;padding:.5rem;text-align:left;}
 th {background:#1f242c;}
 .flex {display:flex;flex-wrap:wrap;gap:1.2rem;}
 .card {flex:1 1 280px;background:#0f141a;padding:1rem;border-radius:8px;border:1px solid #222;}
 .out {color:var(--ok);}
 .warn {color:var(--danger);font-weight:600;}
 .grid-2 {display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:1rem;}
 figure {margin:0;}
 figcaption {font-size:.75rem;opacity:.7;margin-top:.3rem;}
 .pill {display:inline-block;padding:.25rem .6rem;border-radius:999px;background:#21262d;font-size:.7rem;letter-spacing:.5px;text-transform:uppercase;margin-right:.4rem;}
 .inline {display:inline-block;margin:.25rem .4rem .25rem 0;}
 .btnbar {display:flex;flex-wrap:wrap;gap:.5rem;margin-top:.75rem;}
 .btn {display:inline-flex;align-items:center;gap:.4rem;background:#58a6ff;color:#fff !important;border:0;padding:.55rem .95rem;font-weight:600;border-radius:6px;cursor:pointer;font-size:.9rem;text-decoration:none;}
 .btn:hover{filter:brightness(1.1);} 
 body[data-theme="light"] .btn {background:var(--accent);color:#ffffff !important;}
 footer {text-align:center;padding:2rem 1rem;font-size:.75rem;opacity:.65;}
 .demo-box {border:1px solid #30363d;padding:1rem;border-radius:8px;background:#0f141a;}
 label {display:block;font-size:.8rem;margin-top:.6rem;}
 input,select {background:#0d1117;color:var(--text);border:1px solid #30363d;border-radius:6px;padding:.45rem .6rem;font-size:.85rem;width:100%;}
 button {background:var(--accent);color:#fff;border:0;padding:.55rem .9rem;font-weight:600;border-radius:6px;cursor:pointer;margin-top:.8rem;font-size:.85rem;}button:hover{filter:brightness(1.15);} 
 .result {margin-top:.8rem;font-size:.85rem;word-break:break-word;}
 .tagline {font-size:.9rem;opacity:.8;margin-top:.4rem;}
 body[data-theme="light"] th, body[data-theme="light"] td {border-color:#d0d7de;}
 body[data-theme="light"] th {background:#f6f8fa;}
 body[data-theme="light"] .demo-box {background:#ffffff;border-color:#d0d7de;}
 body[data-theme="light"] input, body[data-theme="light"] select {background:#ffffff;color:#1b1f23;border-color:#d0d7de;}
 body[data-theme="light"] img {border-color:#d0d7de !important;}
 body[data-theme="light"] .card {background:#ffffff;border-color:#d0d7de;}
 body[data-theme="light"] .pill {background:#eef2f6;color:#0e1117;border:1px solid #d0d7de;}
 .ai-badge {display:inline-flex;align-items:center;vertical-align:middle;margin-left:.5rem;padding:.25rem .35rem;border-radius:4px;background:#21262d;color:var(--accent);font-size:.58rem;font-weight:600;letter-spacing:.35px;text-transform:uppercase;border:1px solid #2d333b;line-height:1;height:1.1em;}
 body[data-theme="light"] .ai-badge {background:#e9eef3;border-color:#d0d7de;}
 body[data-theme="light"] header {background:#ffffff;border-bottom:1px solid #d0d7de;}
 body[data-theme="light"] section {box-shadow:0 0 0 1px #d0d7de,0 4px 12px rgba(0,0,0,.08);} 
 body[data-theme="light"] h2 {color:#0e1117;}
 @media (max-width:650px){body{font-size:15px;}header{padding:1rem 1.2rem;}main{padding:1.4rem;}section{padding:1rem 1.1rem;} }
</style>
</head>
<body>
<header>
  <h1>Lab 3 ‚Äì RSA Encryption & Key Cracking</h1>
  <div class="tagline">Overview of <code>lab3-part1.py</code>, <code>lab3-part2.py</code>, <code>lab3-part3.py</code> & helpers.</div>
  <div class="btnbar">
    <a class="btn secondary" href="all-in-one.html" style="font-size:.9rem;">Lab Files Page ‚ñ∂</a>
  </div>
  <span class="ai-badge" title="HTML interface auto-generated by an AI assistant" style="position:absolute;top:1rem;right:9rem;">AI‚ÄëGenerated UI</span>
  <button class="btn secondary" id="themeToggle" aria-label="Toggle light/dark theme" style="position:absolute;top:1rem;right:1rem;">Light Mode</button>
</header>
<main>

<section id="about">
  <h2>Overview</h2>
  <p>This lab explores the RSA cryptosystem across three scripts: key generation + sample encryption/decryption (Part 1), cracking a provided RSA instance by factoring the modulus (Part 2), and measuring how cracking time scales with prime bit length (Part 3). A probabilistic Miller‚ÄìRabin primality test (<code>prime.py</code>) underpins key generation. Below you'll find runnable concepts, sample output, and notes about performance.</p>
  <p><strong>Repository:</strong> <a href="https://github.com/JosephPotapenko/RSA-Key-Cracking" target="_blank" rel="noopener">GitHub ‚Äì RSA-Key-Cracking</a></p>
</section>

<section id="parts">
  <h2>Parts Summary</h2>
  <div class="grid-2">
    <div class="card">
      <div class="pill">Part 1</div>
      <strong>Generate Keys & Encrypt</strong>
      <p>Creates two random primes <em>p</em>, <em>q</em>, computes <code>n = p¬∑q</code>, <code>Œª(n)=lcm(p‚àí1,q‚àí1)</code>, selects <code>e=65537</code>, then derives <code>d = e<sup>-1</sup> mod Œª(n)</code>. Demonstrates encrypt/decrypt in both directions.</p>
      <pre><code>python lab3-part1.py 64
public key is:  (n,e)
private key is: (n,d)
message:        b'test,message'
ciphered:       123456...
deciphered:     b'test,message'
</code></pre>
    </div>
    <div class="card">
      <div class="pill">Part 2</div>
      <strong>Crack Provided Ciphertext</strong>
      <p>Given a fixed public key and ciphertext <code>C</code>, factors <code>n</code> with <code>sympy.primefactors</code> ‚áí obtains <code>p,q</code>, recomputes <code>Œª(n)</code>, finds <code>d</code>, and deciphers <code>M = C^d mod n</code> ‚áí message bytes.</p>
      <pre><code>python lab3-part2.py
p:  ...
q:  ...
lambda(n): ...
d: ...
decrypted message: b'YouDonePassed!!'
</code></pre>
    </div>
    <div class="card">
      <div class="pill">Part 3</div>
      <strong>Timing / Scaling</strong>
      <p>Generates primes of various bit sizes, constructs <code>n</code>, then factors using <code>sympy.primefactors</code>. Repeats to average cracking time and plots bit size vs. time.</p>
      <pre><code>python lab3-part3.py
Testing 64-bit primes
   Test 1: 0.0021 s
   ...
Average for 64-bit
Time: 0.0020 s
...
Plot saved as rsa_crack_times.png
</code></pre>
    </div>
    <div class="card">
      <div class="pill">Helper</div>
      <strong>Miller‚ÄìRabin (prime.py)</strong>
      <p>Probabilistic primality test. <code>gen_prime(bits)</code> loops until a candidate passes 20 rounds of Miller‚ÄìRabin, setting top & bottom bits to ensure size & oddness.</p>
      <pre><code>def gen_prime(nbits):
    while True:
        p = random.getrandbits(nbits)
        p |= 2**nbits | 1
        if miller_rabin(p):
            return p
</code></pre>
    </div>
  </div>
</section>

<section id="interactive">
  <h2>üìù Example: RSA Encryption & Decryption Process</h2>
  <p><strong>Using Python code from <code>lab3-part1.py</code></strong></p>
  <p>Below is a walkthrough showing how the RSA encryption and decryption process works with the Python implementation:</p>
  
  <div class="demo-box" id="toy-box">
    <h3 style="margin-top:0;">Step 1: Generate Keys</h3>
    <pre style="background:#0f141a;padding:1rem;border-radius:6px;"><code># From lab3-part1.py
def make_key(bit_len):
    p = gen_prime(bit_len)  # Generate prime p
    q = gen_prime(bit_len)  # Generate prime q
    while q == p:
        q = gen_prime(bit_len)  # Ensure p ‚â† q
    
    n = p * q
    lm = math.lcm(p-1, q-1)  # Œª(n) = lcm(p-1, q-1)
    e = 65537                # Public exponent
    d = modinv(e, lm)        # Private exponent: d = e‚Åª¬π mod Œª(n)
    
    return ((n,e), (n,d))    # public, private

# Example output:
public_key  = (3127, 65537)   # (n, e)
private_key = (3127, 2753)    # (n, d)
</code></pre>

    <h3>Step 2: Encrypt Message</h3>
    <pre style="background:#0f141a;padding:1rem;border-radius:6px;"><code># From lab3-part1.py
msg = b'test,message'

def cipher(m, e, n):
    i = int.from_bytes(m)  # Convert bytes to integer
    return pow(i, e, n)    # C = M^e mod n

# Example:
message = b'test,message'
print("message:       ", message)
# Output: message:        b'test,message'

print("int from bytes:", int.from_bytes(message))
# Output: int from bytes: 35459967764488549030087532389

x = cipher(message, 65537, 3127)
print("ciphered:      ", x)
# Output: ciphered:       2391
</code></pre>

    <h3>Step 3: Decrypt Ciphertext</h3>
    <pre style="background:#0f141a;padding:1rem;border-radius:6px;"><code># From lab3-part1.py
def dcipher(c, d, n):
    return pow(c, d, n)    # M = C^d mod n

# Example:
y = dcipher(2391, 2753, 3127)
print("deciphered:    ", y.to_bytes(12))
# Output: deciphered:     b'test,message'
</code></pre>

    <h3>üìå Complete Example Output</h3>
    <div style="background:#0a0e12;padding:1rem;border:2px solid var(--ok);border-radius:6px;">
<pre style="margin:0;"><code style="color:var(--ok);">$ python3 lab3-part1.py 64

public key is:  (3039956819131923800469303260782717053853, 65537)
private key is: (3039956819131923800469303260782717053853, 2834452675031667969382743586869863866433)

message:        b'test,message'
int from bytes: 35459967764488549030087532389

ciphered:       1315578006529763640141359009929019255795
deciphered:     b'test,message'

encrypted:      2597117990786094813922290830962878948057
decrypted:      b'test,message'
</code></pre>
    </div>

    <h3>üîê Digital Signatures (Reverse Process)</h3>
    <pre style="background:#0f141a;padding:1rem;border-radius:6px;"><code># From lab3-part1.py - Encrypt with PRIVATE key, decrypt with PUBLIC key
def cipher_d(m, d, n):
    i = int.from_bytes(m)
    return pow(i, d, n)    # Sign with private key

# Example:
ciph = cipher_d(b'test,message', 2753, 3127)
print("encrypted:     ", ciph)
# Output: encrypted:      2597

# Verify with public key
dciph = dcipher(2597, 65537, 3127)
print("decrypted:     ", dciph.to_bytes(12))
# Output: decrypted:      b'test,message'
</code></pre>
  </div>
  
  <p style="margin-top:1rem;"><strong>üí° Key Points:</strong></p>
  <ul style="line-height:1.7;">
    <li>Public key (n, e) encrypts messages ‚Üí only private key (n, d) can decrypt</li>
    <li>Private key (n, d) signs messages ‚Üí public key (n, e) verifies authenticity</li>
    <li>All operations use modular exponentiation: <code>pow(base, exponent, modulus)</code></li>
    <li>Œª(n) = lcm(p‚àí1, q‚àí1) is used instead of œÜ(n) for better security</li>
  </ul>
</section>

<section id="functions">
  <h2>Core RSA Functions (Reference)</h2>
  <p>The lab uses raw RSA without padding. Below are the core encryption/decryption operations from the Python implementation. Production systems use larger keys and padding schemes (e.g., OAEP) for security.</p>
  
  <div style="max-width:700px;margin:0 auto;">
    <h3>Python Functions from <code>lab3-part1.py</code></h3>
    <pre style="background:#0f141a;padding:1.5rem;border-radius:8px;"><code># Encryption: Convert message bytes to integer, then encrypt
def cipher(m_bytes, e, n):
    i = int.from_bytes(m_bytes)  # Message as integer
    return pow(i, e, n)          # C = M^e mod n

# Decryption: Decrypt ciphertext, return integer
def dcipher(c, d, n):
    return pow(c, d, n)          # M = C^d mod n

# Digital Signature: Sign with private key
def cipher_d(m_bytes, d, n):
    i = int.from_bytes(m_bytes)
    return pow(i, d, n)          # S = M^d mod n

# Helper: Modular multiplicative inverse
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        return None              # No inverse exists
    return x % m

# Helper: Extended Euclidean Algorithm
def egcd(a, b):
    x, y, u, v = 0, 1, 1, 0
    while a != 0:
        q, r = b // a, b % a
        m, n = x - u * q, y - v * q
        b, a, x, y, u, v = a, r, u, v, m, n
    return b, x, y
</code></pre>
  </div>
  
  <p style="margin-top:1.5rem;"><strong>RSA Flow:</strong> Key generation selects primes p, q ‚Üí n = p√óq ‚Üí Œª(n) = lcm(p‚àí1, q‚àí1) ‚Üí choose e (typically 65537) ‚Üí compute d = e<sup>‚àí1</sup> mod Œª(n). <br/>
  <strong>Encryption:</strong> C = M<sup>e</sup> mod n &nbsp;|&nbsp; <strong>Decryption:</strong> M = C<sup>d</sup> mod n</p>
</section>
<section id="usage">
  <h2>How to Run Locally</h2>
  <table>
    <thead><tr><th>Part</th><th>Command</th><th>Notes</th></tr></thead>
    <tbody>
      <tr><td>Part 1</td><td><code>python lab3-part1.py 64</code></td><td>Adjust bit length (‚â• 32). Uses Miller‚ÄìRabin to generate primes.</td></tr>
      <tr><td>Part 2</td><td><code>python lab3-part2.py</code></td><td>Static values from assignment; prints cracked message.</td></tr>
      <tr><td>Part 3</td><td><code>python lab3-part3.py</code></td><td>May take minutes+ for higher bit sizes. Edit <code>bit_sizes</code> list to shorten.</td></tr>
    </tbody>
  </table>
  <p>Requirements: Python 3.9+, modules: <code>sympy</code>, <code>matplotlib</code>. Install with:</p>
  <pre><code>pip install sympy matplotlib</code></pre>
</section>

<section id="notes">
  <h2>Conceptual Recap</h2>
  <ul>
    <li><strong>Key Generation:</strong> pick primes p,q ‚Üí n=pq ‚Üí Œª(n)=lcm(p-1,q-1) ‚Üí choose e (65537) ‚Üí d= e<sup>-1</sup> mod Œª(n).</li>
    <li><strong>Encrypt:</strong> C = M^e mod n.</li>
    <li><strong>Decrypt:</strong> M = C^d mod n.</li>
    <li><strong>Cracking (simplified):</strong> factor n ‚áí get p,q ‚áí derive d ‚áí decrypt.</li>
    <li><strong>Security:</strong> relies on difficulty of factoring large n.</li>
  </ul>
</section>

<section id="limitations">
  <h2>Limitations & Extensions</h2>
  <ul>
    <li>Uses <code>sympy.primefactors</code>; real attacks use advanced algorithms (e.g., Quadratic Sieve, Number Field Sieve).</li>
    <li>No padding (e.g., OAEP); raw RSA is insecure for real messages.</li>
    <li>No side-channel considerations.</li>
    <li>Could extend Part 3 to log data to CSV and fit growth curves.</li>
  </ul>
</section>

</main>
<footer>
  &copy; 2025 RSA Lab Demo ‚Ä¢ <a href="https://github.com/JosephPotapenko/RSA-Key-Cracking" target="_blank" rel="noopener">View Source</a>
</footer>
<script>
// Theme Toggle / Persistence
(function(){
  const body=document.body;
  const btn=document.getElementById('themeToggle');
  function apply(mode){
    if(mode==='light'){body.setAttribute('data-theme','light'); btn.textContent='Dark Mode';}
    else {body.removeAttribute('data-theme'); btn.textContent='Light Mode';}
  }
  const stored=localStorage.getItem('theme');
  apply(stored==='light'?'light':'dark');
  btn.addEventListener('click',()=>{
    const next= body.getAttribute('data-theme')==='light' ? 'dark' : 'light';
    localStorage.setItem('theme', next);
    apply(next);
  });
})();
</script>
</body>
</html>
